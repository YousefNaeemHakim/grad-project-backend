# Algorithms
Algorithms are the unsung heroes of computer science, tirelessly working behind the scenes to solve problems big and small. From sorting and searching to dynamic programming, these algorithms are the backbone of modern technology, powering everything from search engines and social networks to self-driving cars and space exploration. With their elegant solutions and complex calculations, algorithms represent the perfect marriage of mathematics and computer science, a testament to the power of human ingenuity and the limitless potential of technology. So whether you're a seasoned programmer or just starting out, dive into the world of algorithms and discover the magic that makes computers tick.

## Sorting Algorithms

- Bubble Sort: repeatedly swap adjacent elements until the list is sorted (O(n^2)).
- Selection Sort: repeatedly find the minimum element and swap it with the next unsorted element (O(n^2)).
- Insertion Sort: build the sorted list one element at a time by inserting each new element in its proper place (O(n^2)).
- Merge Sort: divide the list in half recursively, sort each half, and then merge the sorted halves (O(n log n)).
- Quick Sort: choose a pivot, partition the list into elements less than and greater than the pivot, and recursively sort each partition (O(n log n) on average, worst case O(n^2)).
- Heap Sort: build a binary heap, repeatedly extract the maximum element and heapify the remaining elements (O(n log n)).

## Search Algorithms

- Linear Search: iterate through the list until the desired element is found (O(n)).
- Binary Search: divide the sorted list in half recursively until the desired element is found (O(log n)).
- Breadth-First Search (BFS): visit all nodes at a given level before proceeding to the next level (O(|V|+|E|)).
- Depth-First Search (DFS): explore as far as possible along each branch before backtracking (O(|V|+|E|)).

## Dynamic Programming

- Solve a problem by breaking it down into smaller subproblems and reusing solutions to overlapping subproblems.
- Memoization: store solutions to subproblems to avoid redundant computation.
- Tabulation: build a table of solutions to subproblems in a bottom-up manner.

There are many more algorithms than can fit on a single cheat sheet, but hopefully this provides a useful starting point.